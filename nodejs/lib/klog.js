// Generated by CoffeeScript 1.3.3

/* AUTHOR
# 
# Billy Moon
#
# http://billy.itaccess.org/
#
*/


/* DERIVED FROM
# 
#  milli
#   by
#  Steve
#  --
#  http://www.steve.org.uk/
#
*/


/* LICENSE
# 
# Copyright (c) 2012 by Billy Moon.  All rights reserved.
# 
# This module is free software;
# you can redistribute it and/or modify it under the MIT license
# The LICENSE file contains the full text of the license.
#
*/


(function() {
  var changeBugState, cmd_add, cmd_append, cmd_close, cmd_delete, cmd_edit, cmd_html, cmd_init, cmd_reopen, cmd_search, cmd_view, editFile, exec, exit, fs, getBugByUIDORNumber, getBugs, getDate, get_confirmation, get_user_details, hook, main, md5, options, opts, pad, parseArgs, print, randomUID, removeClog, switches, usage;

  options = {
    s: 'state',
    m: 'message',
    e: 'editor',
    t: 'type'
  };

  switches = {
    d: 'debug',
    x: 'exit'
  };

  fs = require('fs');

  exec = require("child_process").exec;

  parseArgs = function() {
    var arg, args, i, k, m, na, o, v, validOptions, _i, _len, _ref;
    args = process.argv;
    o = {
      _: [],
      $0: []
    };
    validOptions = [];
    for (k in options) {
      v = options[k];
      validOptions.push(v);
    }
    i = -2;
    na = false;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (m = arg.match(/^--(.+?)(=(.+))?$/)) {
        na = m[1];
        o[m[1]] = m[3] || true;
      } else if (m = arg.match(/^-(.+?)(=(.+))?$/)) {
        if (na = options[m[1]]) {
          if (na === 'message') {
            o[na] = ((_ref = m[3]) != null ? _ref : [m[3]]) | [''];
          } else {
            o[na] = m[3] || true;
          }
        } else if (switches[m[1]]) {
          na = false;
          o[switches[m[1]]] = m[3] || true;
        } else {
          console.log('Unknown flag: ' + m[1]);
          process.exit(1);
        }
      } else if (++i > 0) {
        if (na === 'message') {
          o.message = [arg];
        } else if (na !== false) {
          o[na] = arg;
        } else {
          if (o.message) {
            o.message.push(arg);
          } else {
            o._.push(arg);
          }
        }
        na = false;
      } else {
        o['$0'].push(arg);
      }
    }
    if (o.message) {
      o.message = o.message.join(' ');
    }
    return o;
  };

  /*
  #
  #  Utility functions.
  #
  */


  pad = function(e,t,n){n=n||"0",t=t||2;while((""+e).length<t)e=n+e;return e};

  /*
  #
  # return date in format
  #
  #    yyyy-mm-dd_hh-ii-ss
  #
  */


  getDate = function() {
    var c;
    c = new Date();
    return c.getFullYear() + "-" + pad(c.getMonth() + 1) + "-" + pad(c.getDate() - 5) + "_" + c.toLocaleTimeString().replace(/\D/g, '-') + "." + pad(c.getMilliseconds(), 3);
  };

  /* 
  # Generate a system UID.  This should be created with the hostname and
  # time included, such that collisions when running upon multiple systems
  # are unlikely.
  # 
  # (A bug will be uniquely referenced by the UID, even though in practise
  # people will use bug numbers they are prone to change.)
  # 
  #
  */


  randomUID = function(o, t) {
    var $uid;
    $uid = opts.date + "." + opts.args.email;
    $uid = md5($uid);
    $uid = $uid.replace(/(.{4}).+/, "$1");
    return $uid;
  };

  /* 
  # 
  # Find and return an array of hashes, one for each existing bug.
  #
  */


  getBugs = function() {
    var $body, $number, $results, $status, $title, $type, $uid, buffer, file, files, line, lines, m, _i, _j, _len, _len1;
    files = fs.readdirSync('.klog/');
    files.sort();
    $results = [];
    $number = 1;
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file.match(/\.log$/)) {
        buffer = fs.readFileSync(".klog/" + file);
        lines = buffer.toString().split(/\n/);
        $body = [];
        for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
          line = lines[_j];
          if (m = line.match(/^Title: (.*)/)) {
            $title = m[1];
          } else if (m = line.match(/^Type: (.*)/)) {
            $type = m[1];
          } else if (m = line.match(/^(Added|Modified):(.*)/)) {

          } else if (m = line.match(/^UID: (.*)/)) {
            $uid = m[1];
          } else if (m = line.match(/^Status: (.*)/i)) {
            $status = m[1];
          } else {
            $body.push(line);
          }
        }
        $results.push({
          file: file,
          body: $body,
          number: $number++,
          uid: $uid,
          status: $status,
          type: $type,
          title: $title
        });
      }
    }
    return $results;
  };

  print = function(txt) {
    return console.log(txt);
  };

  /*
  # 
  # Get the data for a given bug, either by number of UID.
  #
  */


  getBugByUIDORNumber = function($arg) {
    var $bug, $bugs, $possible, m, _i, _len;
    $bugs = getBugs();
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $possible = $bugs[_i];
      if (m = $arg.match(/^([0-9]{1,3})$/i)) {
        if (parseInt(m[1]) === $possible.number) {
          $bug = $possible;
        }
      } else {
        if ($arg.toLowerCase() === $possible.uid.toLowerCase()) {
          $bug = $possible;
        }
      }
      if ($bug) {
        return $bug;
      }
    }
    print("Bug not found: " + $arg + "\n");
    return exit(1);
  };

  exit = function(code) {};

  /* 
  # 
  # Open the given file with either the users editor, the systems editor,
  # or as a last resort vim.
  #
  */


  editFile = function(file) {
    var $editor;
    $editor = opts.args.editor || process.env.EDITOR || "vim";
    return exec("" + $editor + " " + file);
  };

  /* 
  # 
  # Remove the "# klog: " prefix from the given file.
  #
  */


  removeClog = function($file) {
    var buffer, content;
    try {
      buffer = fs.readFileSync($file);
    } catch (e) {
      print("Failed to open " + $file);
      exit;

    }
    content = buffer.toString().replace(/^# klog:.*\n/mg, '');
    return fs.writeFileSync($file, content);
  };

  /* 
  #
  # Show the usage of this script and exit.
  #
  */


  usage = function() {
    print('\nklog [options] sub-command [args]\n\n  Available sub-commands:\n\n    add                 - Add a new bug.\n    append              - Append text to an existing bug.\n    close               - Change an open bug to closed.\n    closed              - List all currently closed bugs.\n    edit                - Allow a bug to be edited.\n    delete              - Allow a bug to be deleted.\n    init                - Initialise the system.\n    list|search         - Display existing bugs.\n    open                - List all currently open bugs.\n    reopen              - Change a closed bug to open.\n    view                - Show all details about a specific bug.\n\n  Options:\n    -e, --editor        - Specify which editor to use.\n    -m, --message       - Use the given message rather than spawning an editor.\n    -s, --state         - Restrict matches when searching (open/closed).\n');
    return exit(0);
  };

  md5 = require('./md5.js').MD5.hex_md5;

  hook = function(action, file) {
    return print("hooked " + action + " with " + file);
  };

  /* 
  # 
  # Change the statues of an existing bug.  Valid statuses are
  # "open" and "closed".
  #
  */


  changeBugState = function($value, $state) {
    var $bug, content;
    if (!$state.match(/^(open|closed)$/i)) {
      print("Invalid status " + $state);
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    if ($bug.status === $state) {
      print("The bug is already $state!\n");
      exit(1);
    }
    content = "\n\nModified: " + opts.date + "\nStatus: " + $state + "\n";
    fs.appendFileSync('.klog/' + $bug.file, content);
    return hook($state, $bug.file);
  };

  /*
  # Add a new bug.
  # 
  # The arguments specified are the optional title. 
  #
  */


  cmd_add = function(args, type) {
    var $file, $template, $title, $type, $uid;
    $uid = randomUID(args);
    if (args.length) {
      $title = args.join(" ");
    } else {
      $title = "Untitled bug report";
    }
    $type = type || 'bug';
    $file = ".klog/" + opts.date + "." + $uid + ".log";
    $template = "UID: " + $uid + "\nType: " + $type + "\nTitle: " + $title + "\nAdded: " + opts.date + "\nAuthor: " + opts.args.name + "\nStatus: open\n\n";
    if (opts.args.message) {
      fs.writeFileSync($file, $template + opts.args.message + "\n");
      hook("add", $file);
      return;
    } else {
      $template += "# klog:\n# klog:  Enter your bug report here; it is better to write too much than\n# klog: too little.\n# klog:\n# klog:  Lines beginning with \"# klog:\" will be ignored, and removed,\n# klog: this file is saved.\n# klog:\n";
      fs.writeFileSync($file, $template);
      editFile($file);
      /* one day we could use a bug template file
      if ( -e ".klog/new-bug-template" )
      {
          open( TMP, "<", ".klog/new-bug-template" ) or
            die "Failed to open file $!";
          while ( my $line = <TMP> )
          {
              print FILE $line;
          }
          close(TMP);
      }
      */

    }
    removeClog($file);
    return hook("add", $file);
  };

  /* 
  # Open an editor with a new block appended to the end of the file.
  # 
  # This mostly means:
  # 
  #    1.  find the file associated with a given bug.
  # 
  #    2.  Append the new text.
  # 
  #    3.  Allow the user to edit that file.
  # 
  #
  */


  cmd_append = function(args) {
    var $bug, $out;
    if (!args.length) {
      print("You must specify a bug to append to, either by the UID, or via the number.\nFor example to append text to bug number 3 you'd run:\n\n\tklog append 3\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber(args[0]);
    if (opts.args.message) {
      $out = "\nModified: " + opts.date + "\n" + opts.args.message + "\n";
      fs.appendFileSync('.klog/' + $bug.file, $out);
      return;
    } else {
      $out = "\nModified: " + opts.date + "\n\n";
      fs.appendFileSync('.klog/' + $bug.file, $out);
    }
    editFile(".klog/" + $bug.file);
    removeClog(".klog/" + $bug.file);
    return hook("append", $bug.file);
  };

  /* 
  # 
  # Output a HTML page for the bugs.
  #
  */


  cmd_html = function(args) {
    var $b, $bugs, $closed, $closed_count, $open, $open_count, _i, _j, _k, _len, _len1, _len2;
    $bugs = getBugs();
    $open = [];
    $closed = [];
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $b = $bugs[_i];
      if ($b.status.match(/open/i)) {
        $open.push($b);
      } else {
        $closed.push($b);
      }
    }
    $open_count = $open.length;
    $closed_count = $closed.length;
    print("<!DOCTYPE HTML>\n<html lang=\"en-US\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>klog : issue tracking and time management</title>\n</head>\n<body>\n  \n  <h1>Klog : issue tracking and time management</h1>\n\n  <table>\n  <tr><td><b><a href=\"#open\">Open bugs</a></b></td><td>" + $open_count + "</td></tr>\n  <tr><td><b><a href=\"#closed\">Closed bugs</a></b></td><td>" + $closed_count + "</td></tr>\n  </table>\n\n    <h2 id=\"open\">Open bugs</h2>");
    for (_j = 0, _len1 = $open.length; _j < _len1; _j++) {
      $b = $open[_j];
      print("<blockquote>\n<dl class=\"toggle\">\n<dt>" + $b.title + "</dt>\n<dd><pre>" + $b.body + "</pre></dd>\n</dl>\n</blockquote>");
    }
    print("<h2 id=\"closed\">Closed bugs</h2>\n<blockquote>\n<dl class=\"toggle\">");
    for (_k = 0, _len2 = $closed.length; _k < _len2; _k++) {
      $b = $closed[_k];
      print("<dt>" + $b.title + "</dt>\n<dd><pre>" + $b.body + "</pre></dd>\n</dl>\n</blockquote>");
    }
    return print(" <hr />\n <p style=\"text-align:right;\">Generated by <a href=\"http://billymoon.github.com/klog/\">klog</a>.</p>\n </body>\n</html>");
  };

  /* 
  # 
  # Search the existing bugs.
  # 
  # Here search means "match against title and status".  Either of which
  # is optional.
  #
  */


  cmd_search = function(args, $state) {
    var $b_file, $b_number, $b_status, $b_title, $b_type, $b_uid, $bug, $bugs, $match, $term, $terms, $type, _i, _j, _len, _len1, _ref, _results;
    $terms = args.join(' ');
    $bugs = getBugs();
    if ($state == null) {
      $state = 'all';
    }
    $type = opts.args.type || "all";
    _results = [];
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $bug = $bugs[_i];
      $b_title = $bug.title;
      $b_type = $bug.type;
      $b_status = $bug.status;
      $b_uid = $bug.uid;
      $b_file = $bug.file;
      $b_number = $bug.number;
      if ($state !== "all" && $state.toLowerCase() !== $b_status.toLowerCase()) {
        continue;
      }
      if ($type !== "all" && $type.toLowerCase() !== $b_type.toLowerCase()) {
        continue;
      }
      $match = 1;
      if (args.length) {
        _ref = $terms.split(/[ \t]/);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          $term = _ref[_j];
          if (!$b_title.match(new RegExp($term, 'i'))) {
            $match = 0;
          }
        }
      }
      if (!$match) {
        continue;
      }
      _results.push(print("%" + opts.clrs.green + $b_uid + opts.clrs.reset + " [" + $b_status + "] [" + $b_type + "] " + $b_title));
    }
    return _results;
  };

  /* 
  # 
  # View a specific bug.
  # 
  # This means:
  # 
  #    1.  Find the file associated with the bug.
  #    2.  Open it and print it to the console.
  #
  */


  cmd_view = function(args) {
    var $bug, $value, buffer;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to view, either by the UID, or via the number.\n");
      print("\nFor example to view bug number 3 you'd run:\n");
      print("\tklog view 3\n\n");
      print("Maybe a list of open bugs will help you:\n\n");
      cmd_search();
      print("\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    buffer = fs.readFileSync('.klog/' + $bug.file);
    return print(buffer.toString());
  };

  /* 
  # 
  # Close a given bug.
  #
  */


  cmd_close = function(args) {
    var $value;
    $value = args.join(' ');
    if (!args.length) {
      print("You must specify a bug to close, either by the UID, or via the number.\nFor example to close bug number 3 you'd run:\n\n\tklog close 3\n\n");
      exit(1);
    }
    return changeBugState($value, "closed");
  };

  /* 
  # 
  # Reopen a bug.
  #
  */


  cmd_reopen = function(args) {
    var $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to reopen, either by the UID, or via the number.\nFor example to reopen bug number 3 you'd run:\n\n\tklog reopen 3");
      exit(1);
    }
    return changeBugState($value, "open");
  };

  /* 
  # 
  # Allow a bug to be updated.
  # 
  # This mostly means:
  # 
  # 1.  find the file associated with a given bug.
  # 2.  Allow the user to edit that file.
  #
  */


  cmd_edit = function(args) {
    var $bug, $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to edit, either by the UID, or via the number.\nFor example to edit bug number 3 you'd run:\n\n\tklog edit 3\n\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    editFile('.klog/' + $bug.file);
    return hook("edit", $bug.file);
  };

  /* 
  # Allow a bug to be deleted.
  # 
  # This mostly means:
  # 
  # 1.  find the file associated with a given bug.
  # 2.  delete that file.
  #
  */


  cmd_delete = function(args) {
    var $bug, $file, $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to delete, either by the UID, or via the number.\nFor example to delete bug number 3 you'd run:\n\n\tklog delete 3\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    $file = $bug.file;
    fs.unlinkSync('.klog/' + $file);
    return hook("delete", $bug.file);
  };

  /*
  # 
  # Inititalise a new .klog directory.
  #
  */


  cmd_init = function() {
    if (!fs.existsSync(".klog")) {
      fs.mkdirSync(".klog");
      print("Now you have klogs on!");
      return exit(0);
    } else {
      print("There is already a .klog/ directory present here");
      return exit(1);
    }
  };

  get_user_details = function(callback) {
    if (opts.args.name && opts.args.email) {
      return callback();
    } else {
      return exec('git config --get user.email', function(se, so, e) {
        var stdin;
        if (so.length) {
          opts.args.email = so.replace(/\n/, '');
          return exec('git config --get user.name', function(se, so, e) {
            if (so.length) {
              opts.args.name = so.replace(/\n/, '');
            } else {
              opts.args.name = opts.args.email.replace(/@.+$/, '');
            }
            return callback();
          });
        } else {
          print("Tried to get email address from Git, but could not determine using:\n\n\tgit config --get user.email\n\nIt might be a good idea to set it with:\n\n\tgit options etc...\n");
          print("Please enter your details... (leave blank to abort)");
          stdin = process.openStdin();
          process.stdout.write("Name: ");
          return stdin.addListener("data", function(d) {
            if (!opts.args.name && (opts.args.name = d.toString().substring(0, d.length - 1))) {
              return process.stdout.write("Email: ");
            } else if (!opts.args.email && (opts.args.email = d.toString().substring(0, d.length - 1))) {
              process.stdin.destroy();
              return callback();
            } else {
              print("Error: tried everything, still no name and email!");
              return process.exit(1);
            }
          });
        }
      });
    }
  };

  get_confirmation = function(callback, message) {
    var stdin;
    stdin = process.openStdin();
    process.stdout.write("Are you sure? [yes/yep/yeah/y|no/nope/nah/n]:");
    return stdin.addListener("data", function(d) {
      if (d.toString().match(/y(e(p|s|ah))?/i)) {
        callback();
        return process.stdin.destroy();
      } else {
        if (message) {
          print(message);
        }
        process.stdin.destroy();
        return process.exit(1);
      }
    });
  };

  /*
  #
  # The main routine ************************************************************************************************
  #
  */


  opts = {
    ext: 'log',
    date: getDate()
  };

  main = function() {
    /*
      #
      # Parse the command line options.
      #
    */
    opts.args = parseArgs();
    if (opts.args.debug) {
      print(opts.args);
    }
    if (opts.args.exit) {
      process.exit(0);
    }
    if (opts.args.help || !opts.args._.length) {
      usage();
      process.exit(1);
    } else {
      opts.cmd = opts.args._.shift();
    }
    if (opts.cmd.match(/^init$/i)) {
      return cmd_init();
    } else if (opts.cmd.match(/^add$/i)) {
      return get_user_details(function() {
        return cmd_add(opts.args._, opts.args.type, opts.args.email);
      });
    } else if (opts.cmd.match(/^append$/i)) {
      return get_user_details(function() {
        return cmd_append(opts.args._);
      });
    } else if (opts.cmd.match(/^html$/i)) {
      return cmd_html(opts.args._);
    } else if (opts.cmd.match(/^(list|search)$/i)) {
      if (opts.args.state) {
        return cmd_search(opts.args._, opts.args.state);
      } else {
        return cmd_search(opts.args._, opts.args.state);
      }
    } else if (opts.cmd.match(/^open$/i)) {
      return cmd_search(opts.args._, 'open');
    } else if (opts.cmd.match(/^closed$/i)) {
      return cmd_search(opts.args._, 'closed');
    } else if (opts.cmd.match(/^view$/i)) {
      return cmd_view(opts.args._);
    } else if (opts.cmd.match(/^close$/i)) {
      return cmd_close(opts.args._);
    } else if (opts.cmd.match(/^reopen$/i)) {
      return cmd_reopen(opts.args._);
    } else if (opts.cmd.match(/^edit$/i)) {
      return cmd_edit(opts.args._);
    } else if (opts.cmd.match(/^delete$/i)) {
      cmd_view(opts.args._);
      print("About to delete this bug...");
      return get_confirmation(function() {
        return cmd_delete(opts.args._);
      }, "Phew, that was close!");
    } else {
      return usage();
    }
  };

  opts.clrs = {};

  exec("tput setaf 1", function(se, so, e) {
    opts.clrs.red = so;
    return exec("tput setaf 2", function(se, so, e) {
      opts.clrs.green = so;
      return exec("tput sgr0", function(se, so, e) {
        opts.clrs.reset = so;
        return main();
      });
    });
  });

}).call(this);
