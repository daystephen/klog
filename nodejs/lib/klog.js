// Generated by CoffeeScript 1.3.3

/* AUTHOR
# 
# Billy Moon
#
# http://billy.itaccess.org/
#
*/


/* DERIVED FROM
# 
#  milli
#   by
#  Steve
#  --
#  http://www.steve.org.uk/
#
*/


/* LICENSE
# 
# Copyright (c) 2012 by Billy Moon.  All rights reserved.
# 
# This module is free software;
# you can redistribute it and/or modify it under
# the same terms as Perl itself.
# The LICENSE file contains the full text of the license.
#
*/


(function() {
  var $args, $cmd, argv, changeBugState, cmd_add, cmd_append, cmd_close, cmd_delete, cmd_edit, cmd_html, cmd_init, cmd_reopen, cmd_search, cmd_view, date, editFile, exec, execSync, exit, fs, getBugByUIDORNumber, getBugs, hook, md5, opts, pad, parseCommandLineArguments, print, randomUID, removeClog, usage;

  fs = require('fs');

  exec = require("child_process").exec;

  execSync = require('exec-sync');

  argv = require('optimist').alias('t', 'type').alias('m', 'message').argv;

  /*
  #
  #  Utility functions.
  #
  */


  pad = function(e,t,n){n=n||"0",t=t||2;while((""+e).length<t)e=n+e;return e};

  /*
  #
  # return date in format
  #
  #    yyyy-mm-dd_hh-ii-ss
  #
  */


  date = function() {
    var c;
    c = new Date();
    return c.getFullYear() + "-" + pad(c.getMonth() + 1) + "-" + pad(c.getDate() - 5) + "_" + c.toLocaleTimeString().replace(/\D/g, '-') + "." + pad(c.getMilliseconds(), 3);
  };

  /* 
  # Generate a system UID.  This should be created with the hostname and
  # time included, such that collisions when running upon multiple systems
  # are unlikely.
  # 
  # (A bug will be uniquely referenced by the UID, even though in practise
  # people will use bug numbers they are prone to change.)
  # 
  #
  */


  randomUID = function() {
    var $email, $uid;
    $email = execSync('git config --get user.email');
    $uid = opts.date + "." + $email;
    $uid = md5($uid);
    $uid = $uid.replace(/(.{4}).+/, "$1");
    return $uid;
  };

  /* 
  # 
  # Find and return an array of hashes, one for each existing bug.
  #
  */


  getBugs = function() {
    var $body, $number, $results, $status, $title, $type, $uid, buffer, file, files, line, lines, m, _i, _j, _len, _len1;
    files = fs.readdirSync('.klog');
    files.sort();
    $results = [];
    $number = 1;
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      buffer = fs.readFileSync(".klog/" + file);
      lines = buffer.toString().split(/\n/);
      $body = [];
      for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
        line = lines[_j];
        if (m = line.match(/^Title: (.*)/)) {
          $title = m[1];
        } else if (m = line.match(/^Type: (.*)/)) {
          $type = m[1];
        } else if (m = line.match(/^(Added|Modified):(.*)/)) {

        } else if (m = line.match(/^UID: (.*)/)) {
          $uid = m[1];
        } else if (m = line.match(/^Status: (.*)/i)) {
          $status = m[1];
        } else {
          $body.push(line);
        }
      }
      $results.push({
        file: file,
        body: $body,
        number: $number++,
        uid: $uid,
        status: $status,
        type: $type,
        title: $title
      });
    }
    return $results;
  };

  print = function(txt) {
    return console.log(txt);
  };

  /*
  # 
  # Get the data for a given bug, either by number of UID.
  #
  */


  getBugByUIDORNumber = function($arg) {
    var $bug, $bugs, $possible, m, _i, _len;
    $bugs = getBugs();
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $possible = $bugs[_i];
      if (m = $arg.match(/^([0-9]{1,3})$/i)) {
        if (parseInt(m[1]) === $possible.number) {
          $bug = $possible;
        }
      } else {
        if ($arg.toLowerCase() === $possible.uid.toLowerCase()) {
          $bug = $possible;
        }
      }
      if ($bug) {
        return $bug;
      }
    }
    print("Bug not found: " + $arg + "\n");
    return exit(1);
  };

  exit = function(code) {
    return process.exit(code);
  };

  /* 
  # 
  # Open the given file with either the users editor, the systems editor,
  # or as a last resort vim.
  #
  */


  editFile = function(file) {
    return execSync("sub " + file);
  };

  /* 
  # 
  # Remove the "# klog: " prefix from the given file.
  #
  */


  removeClog = function($file) {
    var buffer, content;
    try {
      buffer = fs.readFileSync($file);
    } catch (e) {
      print("Failed to open " + $file);
      exit;

    }
    content = buffer.toString().replace(/^# klog:.*\n/mg, '');
    return fs.writeFileSync($file, content);
  };

  opts = {
    ext: 'log',
    date: date()
  };

  /*
  #
  # Parse the command line options.
  #
  */


  parseCommandLineArguments = function() {
    if (argv.help) {
      return usage();
    }
  };

  /*  #
    #  Parse options.
    #
    if (
        !GetOptions(
  
            # Help options
            "help",    \$HELP,
            "verbose", \$CONFIG{ 'verbose' }, # only used when creating init directory
  
            # Type of bug (feature / bug / task / etc...)
            "type=s", \$CONFIG{ 'type' },
  
            # Editor & message.
            "editor=s",  \$CONFIG{ 'editor' },
            "message=s", \$CONFIG{ 'message' },
  
            # state, used for search/list
            "state=s",  \$CONFIG{ 'state' }
        ) )
    {
        exit;
    }
    usage() if HELP;
  */


  /* 
  #
  # Show the usage of this script and exit.
  #
  */


  usage = function() {
    print('\nklog [options] sub-command [args]\n\n  Available sub-commands:\n\n    add                 - Add a new bug.\n    append              - Append text to an existing bug.\n    close               - Change an open bug to closed.\n    closed              - List all currently closed bugs.\n    edit                - Allow a bug to be edited.\n    delete              - Allow a bug to be deleted.\n    init                - Initialise the system.\n    list|search         - Display existing bugs.\n    open                - List all currently open bugs.\n    reopen              - Change a closed bug to open.\n    view                - Show all details about a specific bug.\n\n  Options:\n    -e, --editor        - Specify which editor to use.\n    -m, --message       - Use the given message rather than spawning an editor.\n    -s, --state         - Restrict matches when searching.\n');
    return exit(0);
  };

  parseCommandLineArguments();

  md5 = require('./md5.js').MD5.hex_md5;

  hook = function(action, file) {
    return print("hooked " + action + " with " + file);
  };

  /* 
  # 
  # Change the statues of an existing bug.  Valid statuses are
  # "open" and "closed".
  #
  */


  changeBugState = function($value, $state) {
    var $bug, content;
    if (!$state.match(/^(open|closed)$/i)) {
      print("Invalid status " + $state);
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    if ($bug.status === $state) {
      print("The bug is already $state!\n");
      exit(1);
    }
    content = "\n\nModified: " + opts.date + "\nStatus: " + $state + "\n";
    fs.appendFileSync('.klog/' + $bug.file, content);
    return hook($state, $bug.file);
  };

  /*
  # Add a new bug.
  # 
  # The arguments specified are the optional title. 
  #
  */


  cmd_add = function(args, type) {
    var $file, $template, $title, $type, $uid;
    if (args.length) {
      $title = args.join(" ");
    } else {
      $title = "Untitled bug report";
    }
    $type = type || 'bug';
    $uid = randomUID();
    $file = ".klog/" + opts.date + "." + $uid + ".log";
    $template = "UID: " + $uid + "\nType: " + $type + "\nTitle: " + $title + "\nAdded: " + opts.date + "\nStatus: open\n\n";
    if (argv.message) {
      fs.writeFileSync($file, $template + argv.message + "\n");
      hook("add", $file);
      return;
    } else {
      $template += "# klog:\n# klog:  Enter your bug report here; it is better to write too much than\n# klog: too little.\n# klog:\n# klog:  Lines beginning with \"# klog:\" will be ignored, and removed,\n# klog: this file is saved.\n# klog:\n";
      fs.writeFileSync($file, $template);
      editFile($file);
      /* one day we could use a bug template file
      if ( -e ".klog/new-bug-template" )
      {
          open( TMP, "<", ".klog/new-bug-template" ) or
            die "Failed to open file $!";
          while ( my $line = <TMP> )
          {
              print FILE $line;
          }
          close(TMP);
      }
      */

    }
    removeClog($file);
    return hook("add", $file);
  };

  /* 
  # Open an editor with a new block appended to the end of the file.
  # 
  # This mostly means:
  # 
  #    1.  find the file associated with a given bug.
  # 
  #    2.  Append the new text.
  # 
  #    3.  Allow the user to edit that file.
  # 
  #
  */


  cmd_append = function(args) {
    var $bug, $out;
    if (!args.length) {
      print("You must specify a bug to append to, either by the UID, or via the number.\nFor example to append text to bug number 3 you'd run:\n\n\tklog append 3\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($args[0]);
    print($bug);
    if (argv.message) {
      $out = "\nModified: " + opts.date + "\n" + argv.message + "\n";
      fs.appendFileSync('.klog/' + $bug.file, $out);
      return;
    }
    editFile(".klog/" + $bug.file);
    removeClog(".klog/" + $bug.file);
    return hook("append", $bug.file);
  };

  /* 
  # 
  # Output a HTML page for the bugs.
  #
  */


  cmd_html = function(args) {
    var $b, $bugs, $closed, $closed_count, $open, $open_count, _i, _j, _k, _len, _len1, _len2;
    $bugs = getBugs();
    $open = [];
    $closed = [];
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $b = $bugs[_i];
      if ($b.status.match(/open/i)) {
        $open.push($b);
      } else {
        $closed.push($b);
      }
    }
    $open_count = $open.length;
    $closed_count = $closed.length;
    print("<!DOCTYPE HTML>\n<html lang=\"en-US\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>klog : issue tracking and time management</title>\n</head>\n<body>\n  \n  <h1>Klog : issue tracking and time management</h1>\n\n  <table>\n  <tr><td><b><a href=\"#open\">Open bugs</a></b></td><td>" + $open_count + "</td></tr>\n  <tr><td><b><a href=\"#closed\">Closed bugs</a></b></td><td>" + $closed_count + "</td></tr>\n  </table>\n\n    <h2 id=\"open\">Open bugs</h2>");
    for (_j = 0, _len1 = $open.length; _j < _len1; _j++) {
      $b = $open[_j];
      print("<blockquote>\n<dl class=\"toggle\">\n<dt>" + $b.title + "</dt>\n<dd><pre>" + $b.body + "</pre></dd>\n</dl>\n</blockquote>");
    }
    print("<h2 id=\"closed\">Closed bugs</h2>\n<blockquote>\n<dl class=\"toggle\">");
    for (_k = 0, _len2 = $closed.length; _k < _len2; _k++) {
      $b = $closed[_k];
      print("<dt>" + $b.title + "</dt>\n<dd><pre>" + $b.body + "</pre></dd>\n</dl>\n</blockquote>");
    }
    return print(" <hr />\n <p style=\"text-align:right;\">Generated by <a href=\"http://billymoon.github.com/klog/\">klog</a>.</p>\n </body>\n</html>");
  };

  /* 
  # 
  # Search the existing bugs.
  # 
  # Here search means "match against title and status".  Either of which
  # is optional.
  #
  */


  cmd_search = function(args, $state) {
    var $b_file, $b_number, $b_status, $b_title, $b_type, $b_uid, $bug, $bugs, $match, $term, $terms, $type, _i, _j, _len, _len1, _ref, _results;
    $terms = args.join(' ');
    $bugs = getBugs();
    if ($state == null) {
      $state = 'all';
    }
    $type = argv.type || "all";
    _results = [];
    for (_i = 0, _len = $bugs.length; _i < _len; _i++) {
      $bug = $bugs[_i];
      $b_title = $bug.title;
      $b_type = $bug.type;
      $b_status = $bug.status;
      $b_uid = $bug.uid;
      $b_file = $bug.file;
      $b_number = $bug.number;
      if ($state !== "all" && $state.toLowerCase() !== $b_status.toLowerCase()) {
        continue;
      }
      if ($type !== "all" && $type.toLowerCase() !== $b_type.toLowerCase()) {
        continue;
      }
      $match = 1;
      if (args.length) {
        _ref = $terms.split(/[ \t]/);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          $term = _ref[_j];
          if (!$b_title.match(new RegExp($term, 'i'))) {
            $match = 0;
          }
        }
      }
      if (!$match) {
        continue;
      }
      _results.push(print("#" + $b_number + " " + $b_uid + " [" + $b_status + "] [" + $b_type + "] " + $b_title));
    }
    return _results;
  };

  /* 
  # 
  # View a specific bug.
  # 
  # This means:
  # 
  #    1.  Find the file associated with the bug.
  #    2.  Open it and print it to the console.
  #
  */


  cmd_view = function(args) {
    var $bug, $value, buffer;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to view, either by the UID, or via the number.\n");
      print("\nFor example to view bug number 3 you'd run:\n");
      print("\tklog view 3\n\n");
      print("Maybe a list of open bugs will help you:\n\n");
      cmd_search();
      print("\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    buffer = fs.readFileSync('.klog/' + $bug.file);
    return print(buffer.toString());
  };

  /* 
  # 
  # Close a given bug.
  #
  */


  cmd_close = function(args) {
    var $value;
    $value = args.join(' ');
    if (!args.length) {
      print("You must specify a bug to close, either by the UID, or via the number.\nFor example to close bug number 3 you'd run:\n\n\tklog close 3\n\n");
      exit(1);
    }
    return changeBugState($value, "closed");
  };

  /* 
  # 
  # Reopen a bug.
  #
  */


  cmd_reopen = function(args) {
    var $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to reopen, either by the UID, or via the number.\nFor example to reopen bug number 3 you'd run:\n\n\tklog reopen 3");
      exit(1);
    }
    return changeBugState($value, "open");
  };

  /* 
  # 
  # Allow a bug to be updated.
  # 
  # This mostly means:
  # 
  # 1.  find the file associated with a given bug.
  # 2.  Allow the user to edit that file.
  #
  */


  cmd_edit = function(args) {
    var $bug, $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to edit, either by the UID, or via the number.\nFor example to edit bug number 3 you'd run:\n\n\tklog edit 3\n\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    editFile('.klog/' + $bug.file);
    return hook("edit", $bug.file);
  };

  /* 
  # Allow a bug to be deleted.
  # 
  # This mostly means:
  # 
  # 1.  find the file associated with a given bug.
  # 2.  delete that file.
  #
  */


  cmd_delete = function(args) {
    var $bug, $file, $value;
    $value = args.join('');
    if (!args.length) {
      print("You must specify a bug to delete, either by the UID, or via the number.\nFor example to delete bug number 3 you'd run:\n\n\tklog delete 3\n");
      exit(1);
    }
    $bug = getBugByUIDORNumber($value);
    $file = $bug.file;
    fs.unlinkSync('.klog/' + $file);
    return hook("delete", $bug.file);
  };

  /*
  # 
  # Inititalise a new .klog directory.
  #
  */


  cmd_init = function() {
    if (!fs.existsSync(".klog")) {
      fs.mkdirSync(".klog");
      return exit(0);
    } else {
      print("There is already a .klog/ directory present here.\n");
      return exit(1);
    }
  };

  if (!argv._.length) {
    usage();
  } else {
    $cmd = argv._.shift();
    $args = argv._;
  }

  if ($cmd.match(/^init$/i)) {
    cmd_init();
    exit(0);
  } else if ($cmd.match(/^add$/i)) {
    cmd_add($args, argv.type);
    exit(0);
  } else if ($cmd.match(/^append$/i)) {
    cmd_append($args);
    exit(0);
  } else if ($cmd.match(/^html$/i)) {
    cmd_html($args);
    exit(0);
  } else if ($cmd.match(/^(list|search)$/i)) {
    cmd_search($args);
    exit(0);
  } else if ($cmd.match(/^open$/i)) {
    cmd_search($args, 'open');
    exit(0);
  } else if ($cmd.match(/^closed$/i)) {
    cmd_search($args, 'closed');
    exit(0);
  } else if ($cmd.match(/^view$/i)) {
    cmd_view($args);
    exit(0);
  } else if ($cmd.match(/^close$/i)) {
    cmd_close($args);
    exit(0);
  } else if ($cmd.match(/^reopen$/i)) {
    cmd_reopen($args);
    exit(0);
  } else if ($cmd.match(/^edit$/i)) {
    cmd_edit($args);
    exit(0);
  } else if ($cmd.match(/^delete$/i)) {
    cmd_delete($args);
    exit(0);
  } else {
    usage();
  }

  exit(0);

}).call(this);
