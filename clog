#!/usr/bin/perl -w

##### AUTHOR
# 
# Billy Moon
#
# http://billy.itaccess.org/
#
#####

##### DERIVED FROM
# 
#  milli
#   by
#  Steve
#  --
#  http://www.steve.org.uk/
# 
#####

##### LICENSE
# 
# Copyright (c) 2012 by Billy Moon.  All rights reserved.
# 
# This module is free software;
# you can redistribute it and/or modify it under
# the same terms as Perl itself.
# The LICENSE file contains the full text of the license.
# 
#####

#
#  Pragmas
#
use strict;
use warnings;

#
#  Modules
#
use File::Path;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw(gettimeofday);

#
#  Configuration options
#
my %CONFIG;
my $executionDate;

#  Constants
my $ext = 'log'; # file extension for data files

#
#  Parse any command line options.
#
parseCommandLineArguments();

#  Custom Modules

##### MD5 Library

# use Digest::Perl::MD5 'md5_hex';
use strict;
use integer;
use Exporter;
use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);

@EXPORT_OK = qw(md5 md5_hex);

@ISA = 'Exporter';
$VERSION = '1.6';

# I-Vektor
sub A() { 0x67_45_23_01 }
sub B() { 0xef_cd_ab_89 }
sub C() { 0x98_ba_dc_fe }
sub D() { 0x10_32_54_76 }

# for internal use
sub MAX() { 0xFFFFFFFF }

# padd a message to a multiple of 64
sub padding {
    my $l = length (my $msg = shift() . chr(128));    
    $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
    $l = ($l-1)*8;
    $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
}

sub rotate_left($$) {
  #$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  #my $right = $_[0] >> (32 - $_[1]);
  #my $rmask = (1 << $_[1]) - 1;
  ($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  #$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
}

sub gen_code {
  # Discard upper 32 bits on 64 bit archs.
  my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
# FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
# GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  my %f = (
  FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  );
  #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
  #else { %f = %{$CODES{'64bit'}} }

  my %s = (  # shift lengths
  S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  S43 => 15, S44 => 21
  );

  my $insert = "";
  while(<DATA>) {
  chomp;
  next unless /^[FGHI]/;
  my ($func,@x) = split /,/;
  my $c = $f{$func};
  $c =~ s/X(\d)/$x[$1]/g;
  $c =~ s/(S\d{2})/$s{$1}/;
        $c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;

  #my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  $c = "\$r = $2;
        $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  $insert .= "\t$c\n";
  }
  close DATA;
  
  my $dump = '
  sub round {
  my ($a,$b,$c,$d) = @_[0 .. 3];
  my $r;

  ' . $insert . '
  $_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
        ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
  }';
  eval $dump;
  #print "$dump\n";
  #exit 0;
}

gen_code();

sub _encode_hex { unpack 'H*', $_[0] }

#########################################
# Procedural interface:
sub md5_proc {
  my $message = padding(join'',@_);
  my ($a,$b,$c,$d) = (A,B,C,D);
  my $i;
  for $i (0 .. (length $message)/64-1) {
    my @X = unpack 'V16', substr $message,$i*64,64; 
    ($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  }
  pack 'V4',$a,$b,$c,$d;
}

sub md5 { _encode_hex &md5_proc } 

#
#  Ensure we received an argument.
#
my ( $cmd, @args ) = @ARGV;
if ( !defined($cmd) )
{
    usage();
}

#
#  Decide what to do, based upon the command given.
#
if ( $cmd =~ /^init$/i )
{

    #
    #  Initialise.
    #
    cmd_init();
    exit 0;
}
elsif ( $cmd =~ /^add$/i )
{

    #
    #  Add a bug.
    #
    cmd_add(@args);
    exit 0;
}
elsif ( $cmd =~ /^append$/i )
{

    #
    #  Append a section of text to an existing bug report.
    #
    cmd_append(@args);
    exit 0;
}
elsif ( $cmd =~ /^html$/i )
{

    #
    #  Output bugs as a simple HTML page.
    #
    cmd_html(@args);
    exit 0;
}
elsif ( $cmd =~ /^(list|search)$/i )
{

    #
    #  Find bugs.
    #
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^open$/i )
{

    #
    #  List only open bugs.
    #
    $CONFIG{ 'state' } = "open";
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^closed$/i )
{

    #
    #  List only closed bugs.
    #
    $CONFIG{ 'state' } = "closed";
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^view$/i )
{

    #
    #  View a single bug.
    #
    cmd_view(@args);
    exit 0;
}
elsif ( $cmd =~ /^close$/i )
{

    #
    #  Mark a bug as closed.
    #
    cmd_close(@args);
    exit 0;
}
elsif ( $cmd =~ /^reopen$/i )
{

    #
    #  Mark a bug as open.
    #
    cmd_reopen(@args);
    exit 0;
}
elsif ( $cmd =~ /^edit$/i )
{

    #
    #  Edit a bug.
    #
    cmd_edit(@args);
    exit 0;
}
elsif ( $cmd =~ /^delete$/i )
{

    #
    #  Delete a bug.
    #
    cmd_delete(@args);
    exit 0;
}
else
{
    usage();
}

exit 0;

# 
# Parse the command line options.
# 
# 
#####

sub parseCommandLineArguments
{
    my $HELP   = 0;

    #
    #  Parse options.
    #
    if (
        !GetOptions(

            # Help options
            "help",    \$HELP,
            "verbose", \$CONFIG{ 'verbose' }, # only used when creating init directory

            # Type of bug (feature / bug / task / etc...)
            "type=s", \$CONFIG{ 'type' },

            # Editor & message.
            "editor=s",  \$CONFIG{ 'editor' },
            "message=s", \$CONFIG{ 'message' },

            # state, used for search/list
            "state=s",  \$CONFIG{ 'state' }
        ) )
    {
        exit;
    }

    usage() if $HELP;

}


# 
# Show the usage of this script and exit.
# 
# 
#####

sub usage
{

  print <<END;

clog [options] sub-command [args]

  Available sub-commands:

    add                 - Add a new bug.
    append              - Append text to an existing bug.
    close               - Change an open bug to closed.
    closed              - List all currently closed bugs.
    edit                - Allow a bug to be edited.
    delete              - Allow a bug to be deleted.
    init                - Initialise the system.
    list|search         - Display existing bugs.
    open                - List all currently open bugs.
    reopen              - Change a closed bug to open.
    view                - Show all details about a specific bug.

  Options:
    -e, --editor        - Specify which editor to use.
    -m, --message       - Use the given message rather than spawning an editor.
    -s, --state         - Restrict matches when searching.

END
    exit 1;
}


###
###  Handlers for the commands.
###
#############################################################################


# 
# Inititalise a new .clog directory.
# 
# 
#####

sub cmd_init
{
    if ( !-d ".clog" )
    {
        mkpath( ".clog", { verbose => 0 } );
        exit 0;
    }
    else
    {
        print "There is already a .clog/ directory present here.\n";
        exit 1;
    }
}


# 
# Add a new bug.
# 
# The arguments specified are the optional title.
# 
# 
#####

sub cmd_add
{
    my (@args) = (@_);

    my $title = undef;
    if ( scalar(@args) )
    {
        $title = join( " ", @args );
    }

    $title = "Untitled bug report" unless ( defined($title) );

    my $type =  $CONFIG{ 'type'} || 'bug';

    #
    #  Make a "random" filename, with the same UID as the content.s
    #
    my $uid  = randomUID();
    my $file = ".clog/".date().".$uid.log";

    my $date = date();

    #
    #  Write our template to it
    #
    open( FILE, ">", $file );
    print FILE<<EOF;
UID: $uid
Type: $type
Title: $title
Added: $date
Status: open

EOF


    #
    #  If we were given a message, add it to the file, and return without
    # invoking the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print FILE $CONFIG{ 'message' };
        print FILE "\n";
        close(NEW);
        return;
    }


    if ( -e ".clog/new-bug-template" )
    {
        open( TMP, "<", ".clog/new-bug-template" ) or
          die "Failed to open file $!";
        while ( my $line = <TMP> )
        {
            print FILE $line;
        }
        close(TMP);
    }
    else
    {

        #
        #  Otherwise add the default text, and show it in an editor.
        #
        print FILE<<EOF;
# clog:
# clog:  Enter your bug report here; it is better to write too much than
# clog: too little.
# clog:
# clog:  Lines beginning with "# clog:" will be ignored, and removed,
# clog: this file is saved.
# clog:

EOF
        close(FILE);
    }


    #
    #  Open the file in the users' editor.
    #
    editFile($file);

    #
    #  Once it was saved remove the lines that mention "# clog: "
    #
    removeClog($file);

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "add", $file );
    }
}

# 
# Output a HTML page for the bugs.
# 
# 
#####

sub cmd_html
{
    my (@args) = (@_);

    #
    #  Get all bugs.
    #
    my $bugs = getBugs();


    #
    #  Open + closed bugs.
    #
    my $open;
    my $closed;

    foreach my $b (@$bugs)
    {
        if ( $b->{ 'status' } =~ /open/i )
        {
            push( @$open, $b );
        }
        else
        {
            push( @$closed, $b );
        }
    }

    #
    #  Sort both lists by date.
    #

    #
    #  Counts
    #
    my $open_count   = $open   ? scalar(@$open)   : 0;
    my $closed_count = $closed ? scalar(@$closed) : 0;


    print <<EOH;
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr">
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <title>Bug reports</title>
    <script type="text/javascript" src="http://static.steve.org.uk/js/jquery/jquery.js"></script>
    <script type="text/javascript" src="http://www.steve.org.uk/jquery/dltoggle/jquery.dltoggle.js"></script>
    <script type="text/javascript">
   \$('.toggle').dltoggle( { "open-image"   : "http://steve.org.uk/jquery/dltoggle/open.gif",
                         "closed-image" : "http://steve.org.uk/jquery/dltoggle/closed.gif" } );
    </script>
</head>

 <body>
  <div style="text-align: center;"><h1>Bug Reports</h1></div>
EOH

    print <<EOT;
  <table>
  <tr><td><b><a href="#open">Open bugs</a></b></td><td>$open_count</td></tr>
  <tr><td><b><a href="#closed">Closed bugs</a></b></td><td>$closed_count</td></tr>
  </table>
EOT

    print "<h2 id=\"open\">Open bugs</h2>\n";
    print "<blockquote>\n";
    print "<dl class=\"toggle\">\n";
    foreach my $b (@$open)
    {
        print "<dt>$b->{'title'}</dt>\n";
        print "<dd><pre>$b->{'body'}</pre></dd>\n";

    }
    print "</dl>\n";
    print "</blockquote>\n";

    print "<h2 id=\"closed\">Closed bugs</h2>\n";
    print "<blockquote>\n";
    print "<dl class=\"toggle\">\n";
    foreach my $b (@$closed)
    {
        print "<dt>$b->{'title'}</dt>\n";
        print "<dd><pre>$b->{'body'}</pre></dd>\n";
    }
    print "</dl>\n";
    print "</blockquote>\n";

    print <<EOF;
 <hr />
 <p style="text-align:right;">Produced by <a href="http://steve.org.uk/Software/clog/">clog</a>.</p>
 </body>
</html>
EOF
}

# 
# Search the existing bugs.
# 
# Here search means "match against title and status".  Either of which
# is optional.
# 
# 
#####

sub cmd_search
{
    my (@args) = (@_);

    #
    #  The search terms, if any.
    #
    my $terms = join( " ", @args );

    #
    #  Get all available bugs.
    #
    my $bugs = getBugs();

    #
    #  The state of the bugs the user is interested in.
    #
    my $status = $CONFIG{ 'state' } || "all";

    #
    #  The type of the bugs the user is interested in.
    #
    my $type = $CONFIG{ 'type' } || "all";

    #
    #  For each bug
    #
    foreach my $bug (@$bugs)
    {

        #
        #  Find basic meta-data.
        #
        my $b_title  = $bug->{ 'title' };
        my $b_type  = $bug->{ 'type' };
        my $b_status = $bug->{ 'status' };
        my $b_uid    = $bug->{ 'uid' };
        my $b_file   = $bug->{ 'file' };
        my $b_number = $bug->{ 'number' };

        #
        #  If the user is being specific about status then
        # skip ones that don't match, as this is cheap.
        #
        if ( $status ne "all" )
        {
            next if ( lc($status) ne lc($b_status) );
        }

        #
        #  If the user is being specific about status then
        # skip ones that don't match, as this is cheap.
        #
        if ( $type ne "all" )
        {
            next if ( lc($type) ne lc($b_type) );
        }

        #
        #  If there are search terms then search the title.
        #
        #  All terms must match.
        #
        my $match = 1;
        if ( length $terms )
        {
            foreach my $term ( split( /[ \t]/, $terms ) )
            {
                if ( $b_title !~ /\Q$term\E/i )
                {
                    $match = 0;
                }
            }
        }

        #
        #  If we didn't find a match move on.
        #
        next unless ($match);

        #
        #  Otherwise show a summary of the bug.
        #
        print sprintf "#%d %s [%6s] [%6s] %s", $b_number, $b_uid, $b_status, $b_type, $b_title . "\n";
    }
}

# 
# Allow a bug to be updated.
# 
# This mostly means:
# 
# 1.  find the file associated with a given bug.
# 2.  Allow the user to edit that file.
# 
# 
#####

sub cmd_edit
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to edit, either by the UID, or via the number.\n";
        print "\nFor example to edit bug number 3 you'd run:\n";
        print "\tclog edit 3\n\n";
        exit 1;
    }

    #
    #  Find the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Edit the file the bug is stored in.
    #
    editFile( $bug->{ 'file' } );

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "edit", $bug->{ 'file' } );
    }
}

# 
# Allow a bug to be deleted.
# 
# This mostly means:
# 
# 1.  find the file associated with a given bug.
# 2.  delete that file.
# 
#####

sub cmd_delete
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to delete, either by the UID, or via the number.\n";
        print "\nFor example to delete bug number 3 you'd run:\n";
        print "\tclog delete 3\n\n";
        exit 1;
    }

    #
    #  Find the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Delete the file the bug is stored in.
    #
    my $file = $bug->{ 'file' };
    `rm $file`;

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "delete", $bug->{ 'file' } );
    }
}

# 
# Open an editor with a new block appended to the end of the file.
# 
# This mostly means:
# 
#    1.  find the file associated with a given bug.
# 
#    2.  Append the new text.
# 
#    3.  Allow the user to edit that file.
# 
# 
#####

sub cmd_append
{
    my (@args) = (@_);
    my $value = join( "", @args );


    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to append to, either by the UID, or via the number.\n";
        print "\nFor example to append text to bug number 3 you'd run:\n";
        print "\tclog append 3\n\n";
        exit 1;
    }

    #
    #  Get the bug
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Open the file.
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";


    my $date = date();

    #
    #  If we were given a message add it, otherwise spawn the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print NEW "\nModified: $date\n";
        print NEW $CONFIG{ 'message' };
        print NEW "\n";
        close(NEW);
        return;
    }

    #
    #  Write out the new section
    #
    print NEW <<EOF;

Modified: $date

# clog:
# clog:  Enter your bug update here; it is better to write too much than
# clog: too little.
# clog:
# clog:  Lines beginning with "# clog:" will be ignored, and removed, once
# clog: this file is saved.
# clog:
EOF
    close(NEW);

    #
    #  Allow the user to make the edits.
    #
    editFile( $bug->{ 'file' } );

    #
    #  Once it was saved remove the lines that mention "# clog: "
    #
    removeClog( $bug->{ 'file' } );

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "append", $bug->{ 'file' } );
    }

}

# 
# View a specific bug.
# 
# This means:
# 
#    1.  Find the file associated with the bug.
#    2.  Open it and print it to the console.
# 
# 
#####

sub cmd_view
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to view, either by the UID, or via the number.\n";
        print "\nFor example to view bug number 3 you'd run:\n";
        print "\tclog view 3\n\n";

        print "Maybe a list of open bugs will help you:\n\n";

        cmd_search();

        print "\n";

        exit 1;
    }

    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Show it to the console
    #
    open( FILE, "<", $bug->{ 'file' } ) or
      die "Failed to open file for reading $bug->{'file'} $!";

    while ( my $line = <FILE> )
    {
        print $line;
    }
    close(FILE);

}


# 
# Close a given bug.
# 
# 
#####

sub cmd_close
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to close, either by the UID, or via the number.\n";
        print "\nFor example to close bug number 3 you'd run:\n";
        print "\tclog close 3\n\n";
        exit 1;
    }

    changeBugState( $value, "closed" );
}

# 
# Reopen a bug.
# 
# 
#####

sub cmd_reopen
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to reopen, either by the UID, or via the number.\n";
        print "\nFor example to reopen bug number 3 you'd run:\n";
        print "\tclog reopen 3\n\n";
        exit 1;
    }

    changeBugState( $value, "open" );

}

###
###  Utility functions.
###
#############################################################################

#
# return date in format
#
#    yyyy-mm-dd_hh-ii-ss
#
#####

sub date
{

    if(!$executionDate){
      my ( $time, $microseconds ) = gettimeofday;
      $executionDate = sprintf "%d-%02d-%02d_%02d-%02d-%02d.%06d", map { $$_[5]+1900, $$_[4]+1, $$_[3], $$_[2], $$_[1], $$_[0], $microseconds } [localtime];      
    }

    return $executionDate;
}

# 
# Change the statues of an existing bug.  Valid statuses are
# "open" and "closed".
# 
# 
#####

sub changeBugState
{
    my ( $value, $state ) = (@_);

    #
    #  Ensure the status is valid.
    #
    die "Invalid status $state" unless ( $state =~ /^(open|closed)$/i );


    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Ensure the bug isn't already in the specified state.
    #
    if ( lc( $bug->{ 'status' } ) eq lc($state) )
    {
        print "The bug is already $state!\n";
        exit 1;
    }

    #
    #  Open the file
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";

    #
    #  Now write out the new status section.
    #
    my $date = date();
    print NEW <<EOF;

Modified: $date
Status: $state

EOF

    close(NEW);

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", $state, $bug->{ 'file' } );
    }
}

# 
# Generate a system UID.  This should be created with the hostname and
# time included, such that collisions when running upon multiple systems
# are unlikely.
# 
# (A bug will be uniquely referenced by the UID, even though in practise
# people will use bug numbers they are prone to change.)
# 
# 
#####

sub randomUID
{

    #
    #  The values that feed into the filename.
    #
    my $email = `git config --get user.email`;
    chomp $email;
    my $uid = join ".", date(), $email;
    $uid = md5($uid);
    $uid =~ s/(.{4}).+/$1/;

    return ($uid);
}

# 
# Find and return an array of hashes, one for each existing bug.
# 
# 
#####

sub getBugs
{
    my $results;
    my $number = 0;

    foreach my $file ( sort( glob(".clog/*.$ext") ) )
    {
        $number += 1;

        my $status;
        my $title;
        my $type;
        my $uid;
        my $body;

        open( FILE, "<", $file );
        while ( my $line = <FILE> )
        {
            if ( $line =~ /^Title: (.*)/ )
            {
                $title = $1;
            }
         
            if ( $line =~ /^Type: (.*)/ )
            {
                $type = $1;
            }
            elsif ( $line =~ /^(Added|Modified):(.*)/ )
            {

                # ignored.
            }
            elsif ( $line =~ /^UID: (.*)/ )
            {
                $uid = $1;
            }
            elsif ( $line =~ /^Status: (.*)/i )
            {
                $status = $1;
            }
            else
            {
                $body .= $line;
            }

        }
        close(FILE);

        push( @$results,
              {  file   => $file,
                 body   => $body,
                 number => $number,
                 uid    => $uid,
                 status => $status,
                 type => $type,
                 title  => $title
              } );
    }

    return ($results);
}


# 
# Open the given file with either the users editor, the systems editor,
# or as a last resort vim.
# 
# 
#####

sub editFile
{
    my ($file) = (@_);

    #
    #  Open the editor
    #
    my $editor = $CONFIG{ 'editor' } || $ENV{ 'EDITOR' } || "vim";
    system( $editor, $file );

}


# 
# Remove the "# clog: " prefix from the given file.
# 
# 
#####

sub removeClog
{
    my ($file) = (@_);

    my @lines;

    #
    #  Open the source file for reading.
    #
    open( FILE, "<", $file ) or
      die "Failed to open $file - $!";

    #
    #  Read it, and store the contents away.
    #
    while ( my $line = <FILE> )
    {
        push( @lines, $line );
    }
    close(FILE);


    #
    #  Open the file for writing.
    #
    open( NEW, ">", $file ) or
      die "Failed to open $file - $!";

    #
    #  Write the contents, removing any lines matching our marker-pattern
    #
    foreach my $line (@lines)
    {
        next if ( $line =~ /^# clog:/ );
        print NEW $line;
    }
    close(NEW);

}

# 
# Get the data for a given bug, either by number of UID.
# 
# 
#####

sub getBugByUIDORNumber
{
    my ($arg) = (@_);

    #
    #  Get all bugs.
    #
    my $bugs = getBugs();
    my $bug;

    #
    #  For each one.
    #
    foreach my $possible (@$bugs)
    {

        #
        # If the argument was NNNN then look for that bug number.
        #
        if ( $arg =~ /^([0-9]+)$/i )
        {
            $bug = $possible if ( $1 == $possible->{ 'number' } );
        }
        else
        {

            #
            #  Otherwise look for it by UID
            #
            $bug = $possible if ( lc($arg) eq lc( $possible->{ 'uid' } ) );
        }

        return $bug if ( defined($bug) );
    }

    if ( !defined($bug) )
    {
        print "Bug not found: $arg\n";
        exit 1;
    }

}



__DATA__
FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */

