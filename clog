#!/usr/bin/perl -w

##### AUTHOR
# 
# Billy Moon
#
# http://billy.itaccess.org/
#
#####

##### DERIVED FROM
# 
#  milli
#   by
#  Steve
#  --
#  http://www.steve.org.uk/
# 
#####

##### LICENSE
# 
# Copyright (c) 2012 by Billy Moon.  All rights reserved.
# 
# This module is free software;
# you can redistribute it and/or modify it under
# the same terms as Perl itself.
# The LICENSE file contains the full text of the license.
# 
#####

#
#  Pragmas
#
use strict;
use warnings;

#
#  Modules
#
use File::Path;
use Getopt::Long;
use Pod::Usage;
use Time::HiRes qw(gettimeofday);

#  Custom Modules
use Digest::Perl::MD5 'md5_hex';

#
#  Configuration options
#
my %CONFIG;

#
#  Parse any command line options.
#
parseCommandLineArguments();

#
#  Ensure we received an argument.
#
my ( $cmd, @args ) = @ARGV;
if ( !defined($cmd) )
{
    usage();
}

#
#  Decide what to do, based upon the command given.
#
if ( $cmd =~ /^init$/i )
{

    #
    #  Initialise.
    #
    cmd_init();
    exit 0;
}
elsif ( $cmd =~ /^add$/i )
{

    #
    #  Add a bug.
    #
    cmd_add(@args);
    exit 0;
}
elsif ( $cmd =~ /^append$/i )
{

    #
    #  Append a section of text to an existing bug report.
    #
    cmd_append(@args);
    exit 0;
}
elsif ( $cmd =~ /^html$/i )
{

    #
    #  Output bugs as a simple HTML page.
    #
    cmd_html(@args);
    exit 0;
}
elsif ( $cmd =~ /^(list|search)$/i )
{

    #
    #  Find bugs.
    #
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^open$/i )
{

    #
    #  List only open bugs.
    #
    $CONFIG{ 'state' } = "open";
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^closed$/i )
{

    #
    #  List only closed bugs.
    #
    $CONFIG{ 'state' } = "closed";
    cmd_search(@args);
    exit 0;
}
elsif ( $cmd =~ /^view$/i )
{

    #
    #  View a single bug.
    #
    cmd_view(@args);
    exit 0;
}
elsif ( $cmd =~ /^close$/i )
{

    #
    #  Mark a bug as closed.
    #
    cmd_close(@args);
    exit 0;
}
elsif ( $cmd =~ /^reopen$/i )
{

    #
    #  Mark a bug as open.
    #
    cmd_reopen(@args);
    exit 0;
}
elsif ( $cmd =~ /^edit$/i )
{

    #
    #  Edit a bug.
    #
    cmd_edit(@args);
    exit 0;
}
else
{
    usage();
}

exit 0;

# 
# Parse the command line options.
# 
# 
#####

sub parseCommandLineArguments
{
    my $HELP   = 0;

    #
    #  Parse options.
    #
    if (
        !GetOptions(

            # Help options
            "help",    \$HELP,
            "verbose", \$CONFIG{ 'verbose' }, # only used when creating init directory

            # Editor & message.
            "editor=s",  \$CONFIG{ 'editor' },
            "message=s", \$CONFIG{ 'message' },

            # state, used for search/list, status is a synonym
            "state=s",  \$CONFIG{ 'state' }
        ) )
    {
        exit;
    }

    usage() if $HELP;

}


# 
# Show the usage of this script and exit.
# 
# 
#####

sub usage
{

  print <<END;

clog [options] sub-command [args]

  Available sub-commands:

    add                 - Add a new bug.
    append              - Append text to an existing bug.
    close               - Change an open bug to closed.
    closed              - List all currently closed bugs.
    edit                - Allow a bug to be edited.
    init                - Initialise the system.
    list|search         - Display existing bugs.
    open                - List all currently open bugs.
    reopen              - Change a closed bug to open.
    view                - Show all details about a specific bug.

  Options:
    -e, --editor        - Specify which editor to use.
    -m, --message       - Use the given message rather than spawning an editor.
    -s, --state         - Restrict matches when searching.

END
    exit 1;
}


###
###  Handlers for the commands.
###
#############################################################################


# 
# Inititalise a new .clog directory.
# 
# 
#####

sub cmd_init
{
    if ( !-d ".clog" )
    {
        mkpath( ".clog", { verbose => 0 } );
        exit 0;
    }
    else
    {
        print "There is already a .clog/ directory present here.\n";
        exit 1;
    }
}


# 
# Add a new bug.
# 
# The arguments specified are the optional title.
# 
# 
#####

sub cmd_add
{
    my (@args) = (@_);

    my $title = undef;
    if ( scalar(@args) )
    {
        $title = join( " ", @args );
    }

    $title = "Untitled bug report" unless ( defined($title) );

    #
    #  Make a "random" filename, with the same UID as the content.s
    #
    my $uid  = randomUID();
    my $file = ".clog/$uid.clog";

    my $date = scalar localtime;

    #
    #  Write our template to it
    #
    open( FILE, ">", $file );
    print FILE<<EOF;
Title: $title
UID: $uid
Added: $date
Status: open

EOF


    #
    #  If we were given a message, add it to the file, and return without
    # invoking the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print FILE $CONFIG{ 'message' };
        print FILE "\n";
        close(NEW);
        return;
    }


    if ( -e ".clog/new-bug-template" )
    {
        open( TMP, "<", ".clog/new-bug-template" ) or
          die "Failed to open file $!";
        while ( my $line = <TMP> )
        {
            print FILE $line;
        }
        close(TMP);
    }
    else
    {

        #
        #  Otherwise add the default text, and show it in an editor.
        #
        print FILE<<EOF;
# clog:
# clog:  Enter your bug report here; it is better to write too much than
# clog: too little.
# clog:
# clog:  Lines beginning with "# clog:" will be ignored, and removed,
# clog: this file is saved.
# clog:

EOF
        close(FILE);
    }


    #
    #  Open the file in the users' editor.
    #
    editFile($file);

    #
    #  Once it was saved remove the lines that mention "# clog: "
    #
    removeClog($file);

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "add", $file );
    }
}

# 
# Output a HTML page for the bugs.
# 
# 
#####

sub cmd_html
{
    my (@args) = (@_);

    #
    #  Get all bugs.
    #
    my $bugs = getBugs();


    #
    #  Open + closed bugs.
    #
    my $open;
    my $closed;

    foreach my $b (@$bugs)
    {
        if ( $b->{ 'status' } =~ /open/i )
        {
            push( @$open, $b );
        }
        else
        {
            push( @$closed, $b );
        }
    }

    #
    #  Sort both lists by date.
    #

    #
    #  Counts
    #
    my $open_count   = $open   ? scalar(@$open)   : 0;
    my $closed_count = $closed ? scalar(@$closed) : 0;


    print <<EOH;
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr">
 <head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <title>Bug reports</title>
    <script type="text/javascript" src="http://static.steve.org.uk/js/jquery/jquery.js"></script>
    <script type="text/javascript" src="http://www.steve.org.uk/jquery/dltoggle/jquery.dltoggle.js"></script>
    <script type="text/javascript">
   \$('.toggle').dltoggle( { "open-image"   : "http://steve.org.uk/jquery/dltoggle/open.gif",
                         "closed-image" : "http://steve.org.uk/jquery/dltoggle/closed.gif" } );
    </script>
</head>

 <body>
  <div style="text-align: center;"><h1>Bug Reports</h1></div>
EOH

    print <<EOT;
  <table>
  <tr><td><b><a href="#open">Open bugs</a></b></td><td>$open_count</td></tr>
  <tr><td><b><a href="#closed">Closed bugs</a></b></td><td>$closed_count</td></tr>
  </table>
EOT

    print "<h2 id=\"open\">Open bugs</h2>\n";
    print "<blockquote>\n";
    print "<dl class=\"toggle\">\n";
    foreach my $b (@$open)
    {
        print "<dt>$b->{'title'}</dt>\n";
        print "<dd><pre>$b->{'body'}</pre></dd>\n";

    }
    print "</dl>\n";
    print "</blockquote>\n";

    print "<h2 id=\"closed\">Closed bugs</h2>\n";
    print "<blockquote>\n";
    print "<dl class=\"toggle\">\n";
    foreach my $b (@$closed)
    {
        print "<dt>$b->{'title'}</dt>\n";
        print "<dd><pre>$b->{'body'}</pre></dd>\n";
    }
    print "</dl>\n";
    print "</blockquote>\n";

    print <<EOF;
 <hr />
 <p style="text-align:right;">Produced by <a href="http://steve.org.uk/Software/clog/">clog</a>.</p>
 </body>
</html>
EOF
}

# 
# Search the existing bugs.
# 
# Here search means "match against title and status".  Either of which
# is optional.
# 
# 
#####

sub cmd_search
{
    my (@args) = (@_);

    #
    #  The search terms, if any.
    #
    my $terms = join( " ", @args );

    #
    #  Get all available bugs.
    #
    my $bugs = getBugs();

    #
    #  The state of the bugs the user is interested in.
    #
    my $status = $CONFIG{ 'state' } || "all";

    #
    #  For each bug
    #
    foreach my $bug (@$bugs)
    {

        #
        #  Find basic meta-data.
        #
        my $b_title  = $bug->{ 'title' };
        my $b_status = $bug->{ 'status' };
        my $b_uid    = $bug->{ 'uid' };
        my $b_file   = $bug->{ 'file' };
        my $b_number = $bug->{ 'number' };

        #
        #  If the user is being specific about status then
        # skip ones that don't match, as this is cheap.
        #
        if ( $status ne "all" )
        {
            next if ( lc($status) ne lc($b_status) );
        }

        #
        #  If there are search terms then search the title.
        #
        #  All terms must match.
        #
        my $match = 1;
        if ( length $terms )
        {
            foreach my $term ( split( /[ \t]/, $terms ) )
            {
                if ( $b_title !~ /\Q$term\E/i )
                {
                    $match = 0;
                }
            }
        }

        #
        #  If we didn't find a match move on.
        #
        next unless ($match);

        #
        #  Otherwise show a summary of the bug.
        #
        print sprintf "N:%004d [%6s] %s", $b_number, $b_status, $b_title . "\n";
    }
}

# 
# Allow a bug to be updated.
# 
# This mostly means:
# 
# 1.  find the file associated with a given bug.
# 2.  Allow the user to edit that file.
# 
# 
#####

sub cmd_edit
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to edit, either by the UID, or via the number.\n";
        print "\nFor example to edit bug number 3 you'd run:\n";
        print "\tclog edit 3\n\n";
        exit 1;
    }

    #
    #  Find the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Edit the file the bug is stored in.
    #
    editFile( $bug->{ 'file' } );

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "edit", $bug->{ 'file' } );
    }
}

# 
# Open an editor with a new block appended to the end of the file.
# 
# This mostly means:
# 
#    1.  find the file associated with a given bug.
# 
#    2.  Append the new text.
# 
#    3.  Allow the user to edit that file.
# 
# 
#####

sub cmd_append
{
    my (@args) = (@_);
    my $value = join( "", @args );


    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to append to, either by the UID, or via the number.\n";
        print "\nFor example to append text to bug number 3 you'd run:\n";
        print "\tclog append 3\n\n";
        exit 1;
    }

    #
    #  Get the bug
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Open the file.
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";


    my $date = scalar localtime;

    #
    #  If we were given a message add it, otherwise spawn the editor.
    #
    if ( $CONFIG{ 'message' } )
    {
        print NEW "\nModified: $date\n";
        print NEW $CONFIG{ 'message' };
        print NEW "\n";
        close(NEW);
        return;
    }

    #
    #  Write out the new section
    #
    print NEW <<EOF;

Modified: $date

# clog:
# clog:  Enter your bug update here; it is better to write too much than
# clog: too little.
# clog:
# clog:  Lines beginning with "# clog:" will be ignored, and removed, once
# clog: this file is saved.
# clog:
EOF
    close(NEW);

    #
    #  Allow the user to make the edits.
    #
    editFile( $bug->{ 'file' } );

    #
    #  Once it was saved remove the lines that mention "# clog: "
    #
    removeClog( $bug->{ 'file' } );

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", "append", $bug->{ 'file' } );
    }

}

# 
# View a specific bug.
# 
# This means:
# 
#    1.  Find the file associated with the bug.
#    2.  Open it and print it to the console.
# 
# 
#####

sub cmd_view
{
    my (@args) = (@_);

    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to view, either by the UID, or via the number.\n";
        print "\nFor example to view bug number 3 you'd run:\n";
        print "\tclog view 3\n\n";

        print "Maybe a list of open bugs will help you:\n\n";

        cmd_search();

        print "\n";

        exit 1;
    }

    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Show it to the console
    #
    open( FILE, "<", $bug->{ 'file' } ) or
      die "Failed to open file for reading $bug->{'file'} $!";

    while ( my $line = <FILE> )
    {
        print $line;
    }
    close(FILE);

}


# 
# Close a given bug.
# 
# 
#####

sub cmd_close
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to close, either by the UID, or via the number.\n";
        print "\nFor example to close bug number 3 you'd run:\n";
        print "\tclog close 3\n\n";
        exit 1;
    }

    changeBugState( $value, "closed" );
}

# 
# Reopen a bug.
# 
# 
#####

sub cmd_reopen
{
    my (@args) = (@_);

    #
    #  Get the bug.
    #
    my $value = join( "", @args );

    #
    #  Ensure we know what we're operating upon
    #
    if ( !length($value) )
    {
        print
          "You must specify a bug to reopen, either by the UID, or via the number.\n";
        print "\nFor example to reopen bug number 3 you'd run:\n";
        print "\tclog reopen 3\n\n";
        exit 1;
    }

    changeBugState( $value, "open" );

}

###
###  Utility functions.
###
#############################################################################

#
# return date in format
#
#    yyyy-mm-dd_hh-ii-ss
#
#####

sub date
{
    return sprintf "%d-%02d-%02d_%02d-%02d-%02d", map { $$_[5]+1900, $$_[4]+1, $$_[3], $$_[2], $$_[1], $$_[0] } [localtime];
}

# 
# Change the statues of an existing bug.  Valid statuses are
# "open" and "closed".
# 
# 
#####

sub changeBugState
{
    my ( $value, $state ) = (@_);

    #
    #  Ensure the status is valid.
    #
    die "Invalid status $state" unless ( $state =~ /^(open|closed)$/i );


    #
    #  Get the bug.
    #
    my $bug = getBugByUIDORNumber($value);

    #
    #  Ensure the bug isn't already in the specified state.
    #
    if ( lc( $bug->{ 'status' } ) eq lc($state) )
    {
        print "The bug is already $state!\n";
        exit 1;
    }

    #
    #  Open the file
    #
    open( NEW, ">>", $bug->{ 'file' } ) or
      die "Failed to open file $bug->{'file'} for appending: $!";

    #
    #  Now write out the new status section.
    #
    my $date = scalar localtime;
    print NEW <<EOF;

Modified: $date
Status: $state

EOF

    close(NEW);

    #
    #  If there is a hook, run it.
    #
    if ( -x ".clog/hook" )
    {
        system( ".clog/hook", $state, $bug->{ 'file' } );
    }
}

# 
# Attempt to discover the hostname of the current system.
# 
# 
#####

sub findHostname
{

    #
    #  Run each of the following commands to find the hostname,
    # return the first one that produces non-empty results.
    #
    foreach my $cmd ( "uname -n", "hostname", "cat /etc/hostname",
                      "cat /etc/HOSTNAME" )
    {

        #
        #  Run it.
        #
        my $out = `$cmd`;
        if ( defined($out) )
        {

            #
            #  If there were results.
            #
            chomp($out);
            return $out if ( length($out) );
        }
    }

    return ("unknown.system");
}

# 
# Generate a system UID.  This should be created with the hostname and
# time included, such that collisions when running upon multiple systems
# are unlikely.
# 
# (A bug will be uniquely referenced by the UID, even though in practise
# people will use bug numbers they are prone to change.)
# 
# 
#####

sub randomUID
{

    #
    #  Get the time.
    #
    my ( $time, $microseconds ) = gettimeofday;
    $time = ( $time =~ m/(\d+)/ )[0];
    $microseconds =~ s/\D//g;

    #
    #  The values that feed into the filename.
    #
    my $hostname = findHostname();
    my $email = `git config --get user.email`;
    chomp $email;
    my $namespace = md5_hex($email);
    $namespace =~ s/(.{6}).+/$1/;
    my $file     = join ".", date(), $microseconds, $namespace;

    return ($file);
}

# 
# Find and return an array of hashes, one for each existing bug.
# 
# 
#####

sub getBugs
{
    my $results;
    my $number = 0;

    foreach my $file ( sort( glob(".clog/*.clog") ) )
    {
        $number += 1;

        my $status;
        my $title;
        my $uid;
        my $body;

        open( FILE, "<", $file );
        while ( my $line = <FILE> )
        {
            if ( $line =~ /^Title: (.*)/ )
            {
                $title = $1;
            }
            elsif ( $line =~ /^(Added|Modified):(.*)/ )
            {

                # ignored.
            }
            elsif ( $line =~ /^UID: (.*)/ )
            {
                $uid = $1;
            }
            elsif ( $line =~ /^Status: (.*)/i )
            {
                $status = $1;
            }
            else
            {
                $body .= $line;
            }

        }
        close(FILE);

        push( @$results,
              {  file   => $file,
                 body   => $body,
                 number => $number,
                 uid    => $uid,
                 status => $status,
                 title  => $title
              } );
    }

    return ($results);
}


# 
# Open the given file with either the users editor, the systems editor,
# or as a last resort vim.
# 
# 
#####

sub editFile
{
    my ($file) = (@_);

    #
    #  Open the editor
    #
    my $editor = $CONFIG{ 'editor' } || $ENV{ 'EDITOR' } || "vim";
    system( $editor, $file );

}


# 
# Remove the "# clog: " prefix from the given file.
# 
# 
#####

sub removeClog
{
    my ($file) = (@_);

    my @lines;

    #
    #  Open the source file for reading.
    #
    open( FILE, "<", $file ) or
      die "Failed to open $file - $!";

    #
    #  Read it, and store the contents away.
    #
    while ( my $line = <FILE> )
    {
        push( @lines, $line );
    }
    close(FILE);


    #
    #  Open the file for writing.
    #
    open( NEW, ">", $file ) or
      die "Failed to open $file - $!";

    #
    #  Write the contents, removing any lines matching our marker-pattern
    #
    foreach my $line (@lines)
    {
        next if ( $line =~ /^# clog:/ );
        print NEW $line;
    }
    close(NEW);

}

# 
# Get the data for a given bug, either by number of UID.
# 
# 
#####

sub getBugByUIDORNumber
{
    my ($arg) = (@_);

    #
    #  Get all bugs.
    #
    my $bugs = getBugs();
    my $bug;

    #
    #  For each one.
    #
    foreach my $possible (@$bugs)
    {

        #
        # If the argument was NNNN then look for that bug number.
        #
        if ( $arg =~ /^([0-9]+)$/i )
        {
            $bug = $possible if ( $1 == $possible->{ 'number' } );
        }
        else
        {

            #
            #  Otherwise look for it by UID
            #
            $bug = $possible if ( lc($arg) eq lc( $possible->{ 'uid' } ) );
        }

        return $bug if ( defined($bug) );
    }

    if ( !defined($bug) )
    {
        print "Bug not found: $arg\n";
        exit 1;
    }

}
